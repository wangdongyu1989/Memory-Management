# Memory-Management

交换设备(通常是磁盘，也可以是普通文件)的每个物理页面也要在内存中有个相应的数据结构(或者说“户口”)，不过那些要简单得多，实际上只是一个计数，表示该页面是否已被分配使用，以及有几个用户在共享这个页面。对盘上页面的管理是按文件或磁盘设备来进行的。内核中定义一个swap_info_struct数据结构，用以描述和管理用于页面交换的文件和设备。它的定义包含在include/linux/swap.h中：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410a.jpg)

其中的指针swap_map指向一个数组，该数组中的每一个无符号短整数即代表磁盘上的一个物理页面，而数组的下标则决定了该页面在磁盘或文件上的位置。数组的大小取决于pages，他表示该页面交换设备或文件的大小。设备上（或文件中，设备也是一种文件，下同）的第一个页面，也即swap_map[0]所代表的那个页面是不用于页面交换的，它包含了该设备或文件自身的一些信息以及一个表明那些页面可供使用的位图。这些信息最初是在把改设备格式化成页面交换区时设置的。根据不同的页面交换区格式，还有一些其他页面也不供页面交换使用。这些页面都集中在开头和结尾两个地方，所以swap_info_struct结构中的lowest_bit和highest_bit就说明文件中从什么地方开始到什么地方为止是供页面交换使用的。另一个字段max则表示该设备或文件中最大的页面号，也就是设备或文件的物理大小。

由于存储介质是转动的磁盘，将地址连续的也页面存储在连续的磁盘扇区中不见得是最有效的方法，所以在分配盘上页面空间时尽可能按集群(cluster)方式进行，而字段cluster_next和cluster_nr就是为此而设置的。

Linux内核允许使用多个页面交换设备（或文件），所以在内核中建立了一个swap_info_struct结构的阵列（数组）swap_info:

```c
   struct swap_info_struct swap_info[MAX_SWAPFILES];
``` 

同时，还设立一个队列swap_list,将各个可以分配物理页面的磁盘设备或文件的swap_info_struct结构按优先级高低链接在一起。

```c
    struct swap_list_t swap_list = {-1, -1};
    struct swap_list_t {
           int head;
           int next;
     }
``` 

开始时队列为空，所以head和next均为-1。当系统调用swap_on()指定一个文件用于页面交换时，就将该文件的swap_info_struct结构链入队列中。

就像通过pte_t数据结构（页面表项）将物理内存页面和虚存页面建立联系一样，盘上页面也有这么一个swap_entry_t数据结构：

```c
   typedef struct {
           unsigned long val;
  } swp_entry_t;
```

可见，一个swap_entry_t结构实际上是一个32位无符号整数。但是，这个32位整数实际上分成三个部分：

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410b.jpg)

这里offset表示页面在一个磁盘设备或文件中的位置，也就是文件中的逻辑页面号；而type则是指该页面在哪一个文件中，是个序号。这个位段的命名很容易引起误解，估计这是从pte_t结构中过来的。

当一个页面在内存中是，页面表中的表项pte_t的最低位P标志为1，表示页面在内存中，而其余各位指明物理内存页面的地址及页面的属性。而当一个页面在磁盘上时，则相应的页面表项不在指向一个物理内存页面，而是变成一个swap_entry_t"表项"，指示着这个页面的去向。由于此时其最低位为0，表示页面不在内存，所以CPU中的MMU
单元对其各位都忽略不顾，而留系统软件自己来加以解释。在linux内核中，就用它来唯一地确定一个页面在盘上的位置，包括在哪一个文件或设备，以及页面在此文件中的相对位置。

![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410c.jpg)
![image](https://github.com/wangdongyu1989/Memory-Management/blob/master/images/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%8420170410d.jpg)

先介绍一下一个磁盘页面的函数swap_free()。通过这个函数的阅读，可以加深理解。如果entry.val为0，就显然不需要做任何事，因为在任何页面交换设备或文件中页面0是不用于页面交换的。接着，如前所述，SWAP_TYPE所返回的实际上是页面交换设备的序号，即其swap_info_struct结构在swap_info[]数组中的下标。所以156行以此为下标从swap_info[]中取的具体文件的swap_info_struct结构。

如前所述，offset是页面在文件中的位置，当然不能大于文件本身所提供的最大值。而p->swap_map[offset]是该页面的分配（和使用）计数。如为0就表明尚未分配。同时，分配计数也不应该大于SWAP_MAP_MAX。函数的调用参数count表示有几个使用者释放该页面，所以从计数中减去count。当计数达到0时，这个页面就真正变成空闲了。此时，如果页面落在当前可供分配的范围之外，就要相应地调整这个范围的边界lowest_bit或highest_bit，同时，可供分配的盘上页面的数量nr_swap_pages也增加了。值得注意的是，释放磁盘页面的实际操作实际上并不涉及磁盘操作，而只是在内存中“账面”上的操作，表示磁盘上那个页面的内容已经作废。所以，花费的代价是极小的。

知道了内核怎么管理内存页面和盘上页面以后，就可以来看看内存页面的周转了。当一个内存页面空闲，也就是留在某一个空闲页面管理区的空闲队列中，其page结构中的计数count为0，而在分配页面时将其设置成1.这是在函数rmqueue（）中通过set_page_count（）设置的。

所谓内存页面的周转有两方面的意思。其一是页面的分配，使用和回收，并不一定涉及页面的盘区交换。其二才是盘区交换，而交换的目的最终也是页面的回收。并非所有的内存页面都是可以交换出去的。事实上，只有映射到用户空间的页面才会被换出，而内核，即系统空间的页面则不在此列。这里说明一下，在内核中可以访问所有物理页面，换言之所有物理页面在系统空间都是有映射的。所谓“用户空间的页面”，是指在至少一个进程的用户空间中有映射的页面，反之则为内核使用的页面。
按页面的内容和性质，用户空间的页面有下面几种：
* 普通的用户空间页面，包括进程的代码段，数据段，堆栈段，以及动态分配的“存储堆”。其中有些页面从用户程序即进程的角度是静态的，但是从系统的角度看仍是冬天分配的。
* 通过系统调用mmap（）映射到用户空间的已打开的文件的内容。
* 进程间的共享内存区。

这些页面既涉及分配，使用和回收，也涉及页面的换出/换入。

凡是映射到系统空间的页面都不会被换出，但还是可以按使用和周转的不同而大致分成几类。首先，内核代码和内核中全局量所占的内存页面既不需要经过分配也不会被释放，这部分空间是静态的。（相比之下，进程的代码段和全局量都在用户都再用户空间，所占的内存页面都是动态的，使用前要经过分配，最后都会被释放，并且中途可能被换出而回收后另行分配）

除此之外，内核中使用的内存页面也要经过动态分配，但永远要保留在内存，不会被交换出去。此类常驻内存内存的页面根据其内容的性质可以分成两类。
一类是一旦使用完毕便无保留的价值，所以立即便可释放，回收。这类页面的周转很简单，就是空闲->(分配)->使用->(释放)->空闲。这种用途的内核页面大致有这样一些：
* 内核中通过kmalloc()或vmalloc()分配，用作其某些临时性使用和为管理目的而设的数据结构，如vma_area_struct数据结构等等。这些数据结构一旦使用完毕便无保留价值，所以立即便可释放，不过由于一个页面的往往有多个不同种数据结构，所以要到这个页面都空闲时才能把页面释放。
* 内核中通过alloc_page()分配，用作某些临时性使用和为管理目的的内存页面，如某个进程的系统堆栈所在的两个页面，
